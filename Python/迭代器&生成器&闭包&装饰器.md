## 迭代器

**容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象（iterable）。
可迭代对象实现了__iter__方法，该方法返回一个迭代器对象（iterator）。
迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。**

> iterable -- 可迭代对象
>
>     能够逐一返回其成员项的对象。 可迭代对象的例子包括所有序列类型 (例如 list, str 和 tuple) 以及某些非序列类型例如 dict, 文件对象 以及定义了 __iter__() 方法或是实现了 序列 语义的 __getitem__() 方法的任意自定义类对象。
>    
>     可迭代对象被可用于 for 循环以及许多其他需要一个序列的地方（zip()、map() ...）。当一个可迭代对象作为参数传给内置函数 iter() 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 iter() 或者自己处理迭代器对象。for 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 iterator、sequence 以及 generator。
> iterator -- 迭代器
>
>     用来表示一连串数据流的对象。重复调用迭代器的 __next__() 方法（或将其传给内置函数 next()）将逐个返回流中的项。当没有数据可用时则将引发 StopIteration 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 __next__() 方法只会再次引发 StopIteration 异常。迭代器必须具有 __iter__() 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 list）在你每次向其传入 iter() 函数或是在 for 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。

## 生成器

**生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。**

---

## 闭包

**闭包是指函数离开生成环境后，依然可记住，并持续引用词法作用域里的外部变量。
闭包就是在一个函数里面嵌套一个内部函数，这个内部函数保留了外部方法的作用域。
装饰器可以在不修改原函数的情况下扩展它的功能。**


```python
def make():
    x =2
    return lambda:print(x)

a=make()
a()  # 输出  2
```



**闭包就是函数和所引用环境变量的组合。从这点来看，闭包不等于函数，只是形式上返回函数而已。因引用外部状态，闭包也不是纯函数，再加上闭包会延长外部环境变量的生命周期，理应慎用。
闭包可以是匿名函数也可是普通函数**

---
## 装饰器
**装饰器的形式**
```python
不带参数
import functools

def log(func):     # 装饰器名
    @functools.wraps(func)  #把原始函数的__name__等属性复制到wrapper()函数中
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
'''
使用：
@log
def funcname():
    pass
装饰器展开过程：先log（funcname），返回wrapper函数，覆盖到funcname函数，即 funcname  = log(funcname)
'''
```
```python 
带参数
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func) #把原始函数的__name__等属性复制到wrapper()函数中
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

使用：
@log(text）
def funcname():
    pass
装饰器展开过程：funcname = log(text)(funcname)
```
### @property
**把函数名x变成get属性，可把类.getItem_x()写成类.x，@x.setter 可设置属性赋值**

```python
    class C:
    
    def __init__(self):
        self._x = None
    
    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x
    
    @x.setter
    def x(self, value):
        self._x = value
    
    @x.deleter
    def x(self):
        del self._x

```

### @classmethod
**Transform a method into a class method.**

